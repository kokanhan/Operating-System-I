/*
Author: Han Jiang
Assignment: adventure 
File Name: jianghan.adventure.c
Class: CS344
Due date: 2019/11/1
Submission date: 2019/11/2
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <fcntl.h>
#include <assert.h>
#include <pthread.h>
#include <time.h>
#include <stdbool.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>




char roomFilePath[256];//stores the path of the room file
char newestDirName[256];//stores the path of the newest rooms directory's name
pthread_mutex_t myMutex = PTHREAD_MUTEX_INITIALIZER;//create pthread mutex



/********************************************************************************
* Description: Search for the path to the newest room directory, which is
* generated by jianghan.buildrooms.c 
* Parameters: None
* Returns: None
* Pre-Conditions: jianghan.buildrooms.c has been compiled and run. 
* Post-Conditions: Sets string newestDirName with the path of newsest directory
* name
*********************************************************************************/

void findNewestDir() {
    int newestDirTime = -1; // Modified timestamp of newest subdir examined
    char targetDirPrefix[32] = "jianghan.rooms."; // Prefix we're looking for
    memset(newestDirName, '\0', sizeof(newestDirName));
    DIR* dirToCheck;            // Holds the directory we're starting in
    struct dirent* fileInDir;   // Holds the current subdir of the starting dir
    struct stat dirAttributes;  // Holds information we've gained about subdir

    // Open up the directory this program was run in
    dirToCheck = opendir(".");

    if (dirToCheck > 0) // Make sure the current directory could be opened
    {
        while ((fileInDir = readdir(dirToCheck)) != NULL) // Check each entry in dir
        {
            if (strstr(fileInDir->d_name, targetDirPrefix) != NULL) // If entry has prefix
            {
                stat(fileInDir->d_name, &dirAttributes); // Get attributes of the entry
                if ((int)dirAttributes.st_mtime > newestDirTime) // If this time is bigger
                {
                    newestDirTime = (int)dirAttributes.st_mtime;
                    memset(newestDirName, '\0', sizeof(newestDirName));
                    strcpy(newestDirName, fileInDir->d_name);// Store the directory name into newestDirName
                }
            }
        }
    }
    closedir(dirToCheck); // Close the directory we opened
}

/********************************************************************************
* Description: A player struct which stores the data information
* of the room the player is in.
*********************************************************************************/
struct Player {
    char roomName[26];
    char roomType[26];
    char connections[6][26];
    int numOutboundConnections;
};

/********************************************************************************
* Description: Create the struct Player for the following functions
* Parameters: None
* Returns: The pointer of struct player
* Pre-Conditions: The struct player exists 
* Post-Conditions: The members of the struct player have been initialized
*********************************************************************************/
struct Player* createPlayer() {
    struct Player* player = malloc(sizeof(struct Player));
    assert(player);
    memset(player->roomName,'\0',26);
    memset(player->roomType,'\0',26);
    player->numOutboundConnections = 0;
    return player;
}



/********************************************************************************
* Description: Search for the start room's file path in the newest rooms directory
* and stores the path in roomFilePath
* Parameters: None
* Returns: None
* Pre-Conditions: We have found the newest room directory and stored to newestDirName
* Post-Conditions: The start room's path has been stored in roomFilePath
*********************************************************************************/
void setStartRoom() {
    int file_descriptor; 
    char filePath[256];   // hold the file path of the room file examined
    DIR* dirToCheck;          
    struct dirent* fileInDir; 
    
    dirToCheck = opendir(newestDirName);
    char keyword[2];//Use lseek to find the keyword in start room file
    memset(keyword, '\0', sizeof(keyword));
    memset(roomFilePath, '\0', sizeof(roomFilePath));
    if (dirToCheck > 0) // Make sure the current directory could be opened
    {
        while((fileInDir = readdir(dirToCheck)) != NULL) // Check file in dir
        {
            memset(filePath, '\0', sizeof(filePath));
            sprintf(filePath, "%s%c%s", newestDirName, '/', fileInDir->d_name);//idea about combing the directory name is from my friend
            file_descriptor = open(filePath, O_RDONLY);
            lseek(file_descriptor, (off_t)(-11), SEEK_END);          
            read(file_descriptor, keyword, 1);
            keyword[1]='\0';              
            
            if (keyword[0] == 'S') {
                
                strcpy(roomFilePath, filePath);
            }
        }       
        closedir(dirToCheck);
        }
}



/********************************************************************************
* Description: Read the selected file in the roomFilePath, store information 
* into the struct player*
* Parameters: struct Player* player
* Returns: The pointer of struct player
* Pre-Conditions: The struct player exists 
* Post-Conditions: The members of the struct player have been re-initialized
*********************************************************************************/
void PlayerMove(struct Player* player) {
    ssize_t nread;
    FILE* fp;
    fp = fopen(roomFilePath, "r");
    size_t len = 0;
    char* curr_line = NULL;
    char buffer1[12],buffer2[12], playerData[20];
    player->numOutboundConnections = 0;
    while(nread = getline(&curr_line, &len, fp) != -1){
      sscanf(curr_line, "%s %s %s", buffer1, buffer2, playerData);
      
            if (strcmp(buffer2, "NAME:")==0) {                         
              memset(player->roomName, '\0', sizeof(player->roomName));
              strcpy(player->roomName, playerData);
            }
            if (strcmp(buffer1, "CONNECTION")==0){                          
              memset(player->connections[player->numOutboundConnections], '\0', sizeof(player->connections[player->numOutboundConnections]));
              strcpy(player->connections[player->numOutboundConnections], playerData);
              player->numOutboundConnections++;
            }
            
            if (strcmp(buffer2, "TYPE:")==0){
              memset(player->roomType, '\0', sizeof(player->roomType));
              strcpy(player->roomType, playerData);              
            
            }
            
    }
    free(curr_line);
    fclose(fp);
    
}





/********************************************************************************
* Description: Check if the player has won the game
* Parameters: struct Player* player
* Returns: bool value if_win
* Pre-Conditions: The struct player exists 
* Post-Conditions: None
*********************************************************************************/
bool if_win(struct Player* player){
    if (strcmp(player->roomType, "END_ROOM") == 0 ){
      return true;
	  }
    else{
		  return false;
	  }
}


/********************************************************************************
* Description: Create the time thread
* Parameters: None
* Returns: None
* Pre-Conditions: init and lock myMutex
* Post-Conditions: myMutex has been unlocked, currentTime.txt has been created
*********************************************************************************/
void* createTimeThread(){
    //References://https://stackoverflow.com/questions/1442116/how-to-get-the-date-and-time-values-in-a-c-program
                 //https://stackoverflow.com/questions/5141960/get-the-current-time-in-c
    pthread_mutex_lock(&myMutex);
    int file_descriptor;
    file_descriptor = open("currentTime.txt", O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
    time_t rawtime;   
    time ( &rawtime );
    struct tm *timeinfo = localtime ( &rawtime );
    char buffer [80];
    strftime (buffer,80,"%l:%M%P, %A, %B %d, 20%y\n",timeinfo);
    write(file_descriptor, buffer, strlen(buffer)*sizeof(char));
    close(file_descriptor);
    pthread_mutex_unlock(&myMutex);
}



/********************************************************************************
* Description: Read the time in currentTime.txt and print time result to stdout
* Parameters: None
* Returns: None
* Pre-Conditions: time_thread with createTimeThread function has been spawned
* Post-Conditions: None
*********************************************************************************/
void readTimeFile() {
    FILE *fp;
    char buffer[80];
    char buffer2[83];
    memset(buffer, '\0', sizeof(buffer));
    fp = fopen("currentTime.txt", "r");
    if(fp == NULL) {
      perror("Error opening file");
      exit(1);
    }
    if( fgets (buffer, 80, fp)!=NULL ) {
      /* writing content to stdout */
      strcpy(buffer2,"\n ");
      strcat(buffer2,buffer);
      puts(buffer2);
    }
    fclose(fp);
}



/********************************************************************************
* Description: Provide the interface for user to play the adventure game
* Parameters: None
* Returns: None
* Pre-Conditions: The struct player & room directory exist
* Post-Conditions: The members of the struct player have been re-initialized
*********************************************************************************/
void Game(struct Player* player,pthread_t thread) {

    findNewestDir();
    setStartRoom();
    char* userInput = NULL; 
    size_t bufferSize = 0;   
    int numCharsEntered = 0; 
    int steps =0;
    char playerPath[99][26];
    PlayerMove(player);

    printf("CURRENT LOCATION: %s\n", player->roomName);
    printf("POSSIBLE CONNECTIONS: ");
    int i;
    for (i = 0; i < player->numOutboundConnections; i++) {
        printf("%s", player->connections[i]);
        if (i < player->numOutboundConnections - 1) {
            printf(", ");
        }
    }

    while(!if_win(player)){


        printf("\nWHERE TO? >");
        numCharsEntered = getline(&userInput, &bufferSize, stdin);
        userInput[numCharsEntered - 1] = '\0';// remove input's trailing newline '\n'
        
        bool existence = false; 
        int j;
        for (j = 0; j < player->numOutboundConnections; j++) {//check if userInput is valid for the adventure
          if (strcmp(player->connections[j], userInput) == 0) {
            existence = true;
            break;
          }
        }
        
        
        if (strcmp(userInput, "time") == 0) 
        {
            pthread_mutex_unlock(&myMutex);
            pthread_join(thread,NULL);
            pthread_mutex_lock(&myMutex);
            pthread_create(&thread, NULL, createTimeThread, NULL);
            readTimeFile();
        }
        else if (!existence)
        {
            printf("\nHUH? I DON'T UNDERSTAND THAT ROOM. TRY AGAIN.\n\n");
            printf("CURRENT LOCATION: %s\n", player->roomName);
            printf("POSSIBLE CONNECTIONS: ");
            int i;
            for (i = 0; i < player->numOutboundConnections; i++) {
                printf("%s", player->connections[i]);
                if (i < player->numOutboundConnections - 1) {
                printf(", ");
                }
            }
        }
        else
        {
            steps++;
            memset(roomFilePath, '\0', sizeof(roomFilePath));
            sprintf(roomFilePath, "%s%c%s%s", newestDirName, '/', userInput, "_Room");
            
            PlayerMove(player);
            memset(playerPath[steps], '\0', sizeof(playerPath[steps]));
            strcpy(playerPath[steps], userInput);
            if (strcmp(player->roomType, "END_ROOM") == 0 ){
              break;}
            printf("\n");

            printf("CURRENT LOCATION: %s\n", player->roomName);
            printf("POSSIBLE CONNECTIONS: ");
            int i;
            for (i = 0; i < player->numOutboundConnections; i++) {
                printf("%s", player->connections[i]);
                if (i < player->numOutboundConnections - 1) {
                    printf(", ");
                }
            }
        }
    }


    printf("\nYOU HAVE FOUND THE END ROOM. CONGRATULATIONS!\n");
    printf("YOU TOOK %d STEPS. YOUR PATH TO VICTORY WAS:\n", steps);

    int k;
    for (k = 1; k <= steps; k++) {
        printf("%s\n",playerPath[k]);
    
    }

    free(userInput);


}

int main(void) {
    struct Player* me = createPlayer();
    pthread_mutex_lock(&myMutex);//Lock the mutex from other threads while using while the program is running 
    pthread_t thread;// create thread for "time" input
    pthread_create(&thread, NULL, createTimeThread, NULL);
    Game(me,thread);
    pthread_mutex_unlock(&myMutex);
    pthread_join(thread,NULL);//I have to call pthread_join() to prevent memory leak
    pthread_mutex_destroy(&myMutex);
    free(me);
    return 0;
}



